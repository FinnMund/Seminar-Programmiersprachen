\documentclass{article}
\usepackage{graphicx}
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{sources.bib}

\title{A short Introduction to Zig}
\author{Finn Mund}
\date{January 9, 2026}

\begin{document}
\maketitle
\newpage

\newpage
\thispagestyle{empty} 
\begin{center}
    \makebox[\textwidth][c]{
        \includegraphics[width=1.15\textwidth]{test}
    }
\end{center}
\newpage
\tableofcontents
\newpage


\section{Introduction}
System programming languages are a well-known category of languages in modern software development. They are used in areas such as operating systems, compilers, embedded systems, and performance-critical software.\cite{systemlanguage} They provide developers with direct control over hardware resources, such as memory, while maintaining high performance. Well-known languages include C and Rust, but in recent years, a new and innovative programming language called Zig has been under development.\cite{systemlanguage} While C offers performance but lacks safety and Rust offers safety but is in certain areas to complex, Zig tries to find an middle ground.\cite{zig2016}\cite{padmanabhan2025RustZig} \par
\noindent Due to its unique philosophy, Zig is an interesting language that improves upon traditional concepts and gives a fresh perspective on how modern tooling and safety can be integrated into a middle-level language.\cite{zig2016}
The goal of this work is to provide a brief overview of the Zig programming language, focusing on its historical background, the key features that make the language desirable to learn, the functionalities that distinguish Zig from other languages. Furthermore, this work explores projects powered by Zig, its surrounding infrastructure, and personal insights gained while programming in the language.\par
\noindent It is necessary to mention that this paper is not intended to teach the syntax of Zig. Instead, it focuses on a conceptual understanding, the design decisions, and its value in the world of system programming languages, while highlighting both the strengths and current limitations of the language.
\newpage


\section{History}
The programming language Zig was first mentioned in a blog post by its creator, Andrew Kelley, in February 2016. In this post, he stated that his goal was to develop a programming language that is more pragmatic than C. He further wrote that his intention was not to ignore the success of C over the past decades, but rather to build upon C and address its weaknesses.\cite{zig2016} Since then, Andrew has regularly posted news on the development \cite{zigUpdates}, which was, at the time, a side project alongside his work at the company OkCupid. Therefore, most of the time he could spend working on Zig was limited to nights and weekends, and the only funding came from donations by interested individuals. This remained the ongoing state until June 7, 2018, when he wrote that he had quit his job to work on Zig full-time, funded by the donations he received.\cite{zigJob} On July 11, 2020, Andrew Kelley announced the Zig Software Foundation, which is a non-profit organization. The goal is to promote, protect, and advance Zig, as well as to support the growth of the community by providing education and guidance. One interesting approach of the founder is that he encourages donors not to donate to him personally, but instead to the organization, as this allows donations to be written off from taxable income, and because the legal system requires non-profit foundations to use these donations exclusively for their mission of improving Zig.\cite{zigFoundation2020} Currently, the board members are Andrew Kelley (President), Josh Wolfe (Secretary), and Mason Remaley (Treasurer). Not only private individuals are donating to the mission of Zig, but also larger companies such as TigerBeetle, Blacksmith, ZML, and Silares.\cite{zigSoftwareFoundation} One example of donations comes from TigerBeetle and Synadia. In total, these companies plan to contribute 512,000 dollars over the next two years to the organization.\cite{tigerbeetlePledge2025}
To this day, only one employee works for the Zig Software Foundation, and who is Andrew Kelley himself. The rest of the people who work on Zig are contractors.\cite{zigFinancials2025} Currently, Zig is at version 0.15.2 as of January 2026, and is therefore still in the pre-1.0 stage.\cite{zigDownload}

\section{Why use Zig?}
As mentioned earlier, Zig delivers performance comparable to C while providing low-level control 
over memory and CPU resources\cite{zigOverview}. Like traditional system programming languages\cite{wikiSystemProgrammingLanguage}, Zig allows developers 
to work close to the hardware, making it suitable for applications where efficiency and precise 
resource management are essential. For this reason, Zig does not rely on automatic memory management or garbage collection. Instead, developers are responsible for explicitly allocating and deallocating memory\cite{hexshiftAllocators}. This approach provides precise control over resource usage and program behavior. By avoiding hidden runtime overhead and implicit allocations, Zig ensures predictable performance characteristics, which are essential for system-level software. \cite{padmanabhan2025RustZig}

\noindent In addition to performance, Zig places a strong emphasis on memory safety and robust error handling. While garbage collection can simplify development in high-level languages, it often introduces unpredictable pauses and additional runtime overhead. By avoiding garbage collection entirely, Zig ensures deterministic runtime behavior and eliminates uncontrolled pauses caused by automatic memory reclamation. This design choice allows developers to retain full control over system resources, which is particularly important in real-time systems and environments with limited memory or processing power.\cite{zigComparison}

\noindent Another special approach of Zig is the error handling. Zig defines errors as values, which means that each value stands for a different error type. Examples are OutOfMemory or AccessDenied. This allows Zig to combine errors with different data types with the operator "!". This means that the value of a variable can either be a normal value of any type or an error. To access this value, the developer must use the try operator. This allows the program to check the return value and determine if an error has occurred, ensuring that errors are handled explicitly and cannot be ignored. But Zig also gives other options to handle errors. With the operator catch, developers can provide a default value.\cite{padmanabhan2025RustZig} It is important to mention that the user is not forced to use an error union (for example !i32), but the enforcement happens as soon as an error is introduced. That means if a function tries to return an error, Zig's compiler instructs that the return type should be changed to an error union. Once a function is marked with the ! operator, every other part of the code that calls this function is also forced by the compiler to handle the potential error. This enables the developer to not miss an error chain in their project.\cite{zigDocsErrors}

\noindent While the error handling provides safety during the runtime of a program, Zig has another unique feature: comptime. The idea behind comptime is that certain code marked with the keyword comptime is executed while the program is being compiled. This allows operations like calculations, logic, and the generation of new types to happen before the program ever runs. The advantages of such a feature are increased performance, because expensive calculations happen before the user starts the program.\cite{zigGuideComptime}

\noindent One of the most interesting features of Zig is its built-in support for cross-compilation. This allows developers to compile programs for different computer systems with varying hardware architectures and operating systems from a single codebase. Zig ships with its own compiler, linker, and standard library, which eliminates the need for external cross-compilation toolchains or platform-specific build environments. This approach significantly simplifies development for different types of systems and is particularly useful for embedded systems, low-level tooling, and software that must run reliably across multiple architectures.
\cite{zigGuideCrossCompilation}

\noindent In addition to performance and safety, Zig emphasizes simplicity and readability. Compared to more complex system programming languages, Zig intentionally avoids overly abstract language features in favor of explicit and transparent code. Its minimal syntax and clear conventions make code easier to understand, maintain, and debug, even in large or long-lived projects. This focus on simplicity reduces the risk of bugs, which is especially important in system-level programming.\cite{zigOverviewSimplicity}

\noindent Taken together, these characteristics make Zig a modern, efficient, and practical choice for 
system programming. By combining low-level control, safety, predictable performance, cross-platform 
capabilities, and readable syntax, Zig provides developers with a language that is both powerful 
and accessible for a wide range of system-level applications.


\section{What niche is the language supposed to fill?}
In the area of the system programming language, there are well-established names like C and Rust.They cover a large part of the application area.\cite{tiobeIndex} So the question is now: What makes Zig different, and what right to exist does Zig have in this environment?\par
\noindent Zig is a modern, general-purpose systems programming language whose goal is to handle low-level tasks similarly to C. As mentioned earlier, Zig aims to build upon the success of C while improving areas where C is weak. The areas that are specifically focused on are the combination of safety and performance.\cite{zig2016} While C offers excellent performance and control over hardware resources, it also has some well-known safety issues.\cite{tiobeIndex} These issues mostly appear through manual memory management. When the developer allocates memory on the heap and fails to release it when it's no longer needed, this leads to a loss of the pointer, which makes it impossible for the program to clean it up later. Such problems are extremely challenging because they are often difficult to detect and can have horrendous consequences in, for example, long-running servers.\cite{netdataMemoryLeakC}\par
\noindent Another problem C suffers from are buffer overflows, where data is written beyond the boundaries of a fixed-size buffer. An overflow can result in unwanted behavior or crashes by overwriting important data in the adjacent memory.\cite{netdataMemoryLeakC}\par
\noindent The last problem that will be mentioned is null pointer dereference. In C, any pointer can be null, which can lead to a segmentation fault or a crash. This can happen when the program tries to read or write memory through a pointer and expects a valid object, but it actually contains the value zero.\cite{snykNullDereference}
Zig solves all these aforementioned problems with different features. The first problem, memory leaks, can be fixed in Zig with the keyword defer. After allocating memory, the developer can immediately place the deallocation. Defer assures the freeing of memory at the end of the scope.\cite{zigGuideDefer} Also, every function that needs memory forces the user to pass an allocator. There is also the possibility to use the std.testing.allocator, and the default test runner will report any leaks that are found while using this kind of allocator.\cite{zigStdTesting}
The solution for the buffer overflow problem is the replacement of pointers with slices in most use-cases. This change creates a pointer with a certain length. Because the length is now known, Zig can check runtime bounds.\cite{zigGuideSlices} When an out-of-bounds access happens, the program crashes safely and no data will be overwritten. And the last adaptation of Zig is, that Zig doesn't have nullable pointers by default. When developers need a null value, they must use an optional pointer\cite{zigByExamplePointers}, which requires a check for the null case through the compiler. This extra step makes it nearly impossible to make this kind of mistake.\cite{zigGuidePointers}
But Zig isn't the first language that focuses on safety features. Another competitor for this role is the language Rust, which is a very popular language for large-scale, safety-first applications, with its performance comparable to C and its big ecosystem. But one thing that makes the development difficult is the complexity of using it efficiently. Rust has some very strict borrowing rules, which make reading and writing data under certain conditions a lot more complicated, and Rust has also a very strict compiler. This results often in a lot of errors that occur during coding in Rust, because the compiler does a lot of work in the background to check if all rules are held. On the other hand, Zig focuses on simplicity and performance, which makes it a lot easier for new developers. Also, Zig has an advantage in performance-critical applications.\cite{padmanabhan2025RustZig}

\noindent Compared to C, Zig places a stronger emphasis on safety while still offering low-level control and 
high performance. In contrast to Rust, Zig follows a more explicit and less restrictive approach to 
memory management, aiming to reduce complexity while maintaining competitive performance. This 
positions Zig in a niche between C and Rust within the system programming landscape.


\section{Prominent Projects}
Despite its relatively short time of existence, there are already several prominent projects developed using Zig. These projects range from high-performance runtime environments to distributed databases and developer tooling.\cite{bunDocs}\cite{tigerbeetleDocs}\cite{ziglsGithub}

\noindent One of the more well-known projects developed using Zig is Bun. Bun is a unified tool that combines four different functionalities into a single program. One of these functionalities is a JavaScript runtime, which provides an execution environment for JavaScript code.\cite{bunDocs} This runtime supplies essential Web APIs that enable JavaScript to perform tasks such as network requests, time-based operations, and data or file system access.\cite{runtime} It is designed to be a direct drop-in replacement for Node.js, which is a widely used standard in the programming world.\cite{bunDocs}

\noindent Bun also provides a built-in package manager, which impresses with its high speed and is dramatically faster than comparable tools like npm, yarn, and pnpm. This speed is important because it significantly reduces the time developers normally spend waiting during installation and setup.
Bun includes a test runner, which finds test scripts and applies them to the developer's program code. Through this procedure, the user receives feedback about the quality and functionality of their code. This component also aims to outperform comparable tools. The last feature is a bundler, which organizes modules and combines them into optimized files to improve performance and reduce loading times for browsers.

\noindent All in all, Bun is a four-in-one solution that minimizes the number of required applications while maximizing their speed and efficiency. Bun is written in the programming language Zig, which allows it to be highly efficient and close to the system hardware. The JavaScript code is executed using JavaScriptCore, the engine used by Safari, which runs JavaScript very quickly. These design choices, working behind the scenes, significantly reduce startup times and memory usage, making Bun faster and more lightweight than many other JavaScript runtimes.\cite{bunDocs}

\noindent Another project is the financial transaction database TigerBeetle, whose mission is to provide a safe and reliable foundation for Online Transaction Processing (OLTP) for the next 30 years. One of its key features is high throughput, meaning it can handle a very large number of transactions per second, typically in the range of 100,000 to 500,000 transactions. TigerBeetle also focuses on predictable low latency, which ensures that each transaction is processed with a consistent response time, allowing a stable data flow without unexpected delays or performance fluctuations. Another particularly important feature is cost efficiency, as TigerBeetle requires significantly less hardware due to its highly optimized design. The key to this efficiency lies in its first-principles approach, low-level optimizations, and efficient use of system resources, which reduce overhead and enable the system to scale while keeping infrastructure costs low. The importance of this new approach lies in the growth of transaction volumes over the last ten years. In real-time payment systems, transaction volumes have increased by up to 10,000 times, and other areas such as cloud computing, energy, and gaming are also growing rapidly. Older SQL databases are outdated and cannot keep up with these extreme changes.\cite{tigerbeetleDocs}

\noindent TigerBeetle was implemented in Zig because the system requires precise control over memory management, CPU usage, and I/O behavior. Zig does not rely on garbage collection, which ensures predictable low latency by avoiding unexpected execution pauses. In addition, Zig enables the development of highly optimized and efficient code, making it an ideal choice for performance-critical systems such as TigerBeetle.\cite{tigerbeetlePerformance}

\noindent Beyond databases and runtimes, Zig is also increasingly present in specialized fields such as game development. A prime example is the Mach Engine, whose mission is to enable the creation of high-performance, truly cross-platform, and modular games, visualizations, and desktop or mobile GUI applications. Although the project is still in its early stages of development, it already pursues several innovative architectural approaches that distinguish it from established engines.

\noindent One central "quality of life" objective is to create an engine that is exceptionally easy to set up, requiring only the Zig compiler as a single dependency. The creators of Mach argue that setting up a modern development environment—especially in C++ based engines—often ends in technical frustration and only minor successes due to fragmented toolchains and complex dependency trees. To solve this, Mach carefully selects its dependencies, favoring native Zig implementations and only utilizing C or C++ libraries when absolutely necessary. This should approach significantly lowers the barrier to entry for new developers. Another core pillar of the project is seamless cross-compilation. Mach aims to be deployable to nearly any target architecture or operating system without the need for platform-specific build machines \cite{machGoals}. This is a primary reason why the project was built on Zig, as the language’s ability to target various environments—such as Windows, Linux, macOS, and even WebAssembly—from a single codebase is one of its most powerful technical strengths.\cite{zigGuideCrossCompilation}
 By simply switching a build flag, developers can generate optimized binaries for different systems, a task that traditionally requires hours of manual configuration.\cite{machGoals} Looking toward the future, the ambition of Mach is to evolve into a comprehensive ecosystem that can compete with industry-standard engines. To achieve this, the development team is working on a full suite of integrated tools, including a professional GUI editor, a custom UI library, a high-performance rendering engine, and a native physics module. By combining Zig’s low-level performance with a modern, developer-friendly workflow, Mach seeks to prove that system-level programming in the gaming industry can be both powerful and accessible.\cite{machEngine}

\noindent The last project to be mentioned is the Zig Language Server (ZLS). It is a language server for Zig that provides syntax highlighting, auto-completion, error analysis, and other editor features via the Language Server Protocol (LSP). ZLS is written in Zig itself, demonstrating that Zig can be used not only for low-level system programming but also for developer tooling. It is community-maintained and works with modern editors that support LSP, such as VS Code, Neovim, and JetBrains IDEs.\cite{ziglsGithub}\cite{zigTools}

\noindent After analyzing these various projects, it becomes clear that Zig can be used in a wide variety of software engineering fields. It is also fascinating to observe that so many ambitious projects are choosing to work with this relatively unknown language. This trend highlights a growing interest in Zig’s core philosophy: providing the performance and control of a low-level language while eliminating the hidden complexities and safety risks associated with traditional tools like C.
\newpage
\section{How does the infrastructure around the language work?}
Although Zig is in its pre 1.0 version, there is still an impressive amount of infrastructure build around it. \cite{zigDownload}

\noindent The first feature to mention is that Zig provides its own integrated build system, which is written in Zig itself. This built-in build system reduces the need for additional external software and supports developers by simplifying the build process. It also supports building projects for different target systems, a concept commonly referred to as cross-compilation.
In addition, the Zig build system allows developers to define dependencies on other projects or libraries and integrates them directly into the build process. This enables a consistent and reproducible way to manage external code without relying on third-party build tools, making project setup and maintenance significantly easier.\cite{zigBuildSystemLearn}
One of the most helpful resources for learning Zig is the documentation on the official Zig website. It provides comprehensive information about the language syntax, functions, the standard library, the build system, and practical usage examples. This documentation is particularly important because Zig is still under active development and the language evolves frequently.\cite{zigStdDocs}
In addition to the official documentation, there are several community-driven platforms where users can discuss questions and share information about the language. However, due to Zig’s relatively short existence, the community is still fairly small. As a result, some newer or more advanced concepts can be harder to understand, as fewer learning resources and discussions are available compared to more established programming languages.\cite{ziggitForum}
Zig does not have its own dedicated IDE, but it is supported by various editors through the Zig Language Server (ZLS). This significantly simplifies the process of writing code, as ZLS provides features such as syntax highlighting, code autocompletion, and real-time error checking. As a result, Zig can be comfortably used in popular development environments including Visual Studio Code, Neovim, and JetBrains IDEs.\cite{ziglsGithub}
The last part of the infrastructure to mention is the testing framework. It is built into the Zig standard library and allows developers to write and execute tests directly alongside their code. The testing framework checks whether individual components of a program behave as expected and helps detect errors early in the development process. By integrating testing into the language itself, Zig encourages reliable and maintainable software development.\cite{zigTestDoc}
One key feature that is still missing in the official Zig language ecosystem is a built-in package manager. This makes it more difficult to use third-party libraries, as dependencies must be managed manually and set up locally on each developer’s system. As a result, project setup can become more complex and less reproducible compared to languages with an integrated package management solution. \cite{zigBuildDependencies}
Despite its currently limited infrastructure, Zig is already usable to a certain extent for professional software development. The efforts of the Zig community and development team demonstrate that the language will continue to develop a more mature and comprehensive ecosystem over time.

\section{Code projekt: grep}
As part of this paper, a program is developed using the selected programming language. The program is intended to replicate the core functionality of the well-known grep utility. Specifically, it enables the recursive search for a given regular expression across all files within a specified directory. For this purpose, the user can define a search path, a pattern to be matched, and several options that influence the format of the output.
The objective of this section is to explore the characteristics of the Zig programming language through the implementation of a comparatively simple command-line application, allowing practical experience with its language features and standard library.
The following section gives an overview, what dependency got used for the implementation and how the program was built/designed.

\noindent The first dependency to be mentioned is the Zig standard library. It is a fundamental part of every Zig program and provides a wide range of commonly used algorithms, data structures, and definitions that facilitate program development. By offering these features, the standard library reduces the need to rely on external libraries and simplifies the implementation of common functionality. This standard feature must be defined in every Zig file at the beginning.
\noindent The only additional dependency used in this project was a regular expression library. Since Zig does not include a built-in package manager, the library must be obtained manually and included in the project. That can be achieved by copying a program on the local system and including it in the zig file. This library was necessary because the Zig standard library does not provide comprehensive support for regular expressions, and it allows the program to perform pattern matching efficiently and reliably. This functionality is essential because it allows the program to perform partial matches within a regular expression, enabling more flexible and precise search results. The libary that got used was zig-regex (Repository:** https://github.com/tiehuis/zig-regex) by the user "tiehuis".\par

\noindent My code is separated in three different functions: main, readFile, and searchRe. The first one to be explained is main. The program begins execution in the main function, which serves as the entry point. The first step is the allocation of memory using a general-purpose allocator (std.heap.GeneralPurposeAllocator). This allocator is required to manage dynamic memory for the program, including storage for command-line arguments, buffers for file contents, and temporary data needed during the search process. Command-line arguments are read using the std.process.argsAlloc(allocator) function from Zig’s standard library, which stores the input in the allocator’s memory. One important aspect of memory management in Zig is explicit error handling. The try keyword is used to propagate any allocation errors automatically, ensuring that the program does not continue execution in case of failure. After the allocated memory is no longer needed, it must be freed manually using the allocator’s deinit() or free() functions. This explicit allocation and deallocation pattern is a standard procedure in Zig and must be followed every time dynamic memory is used. For example, when reading command-line arguments, the memory is reserved with argsAlloc, used for processing the input, and then freed with argsFree to avoid memory leaks. The next step is to validate the command-line input by checking for different types of flags. These include cases where the input is invalid, when the user requests help to obtain information on program usage, or when search options such as context lines, color highlighting, case sensitivity, or hidden file inclusion are specified. Depending on the provided flags, the program either displays a usage message, sets internal configuration variables, or reports an error for incorrect input. The final step in preparing the input is to validate the presence of a search pattern and a path, as both are essential for the search operation. If either is missing, the program immediately reports an error and terminates, preventing unnecessary computation. Once both inputs are confirmed, the program prepares the pattern for matching. If case-insensitive search has been requested, the pattern is first converted to lowercase in memory allocated by the general-purpose allocator. After any necessary transformations, the pattern is compiled into a regular expression object using the external regex library. The specified path is then opened, which may point to either a single file or a directory. With the compiled regex and the validated path, the program proceeds to the recursive search function searchRe, which performs the actual traversal of files and directories, applying the pattern matching and respecting all user-specified options such as context lines, color highlighting, and hidden file inclusion.\par

\noindent The searchRe function is responsible for recursively traversing the file system starting from a given path. It iterates over all entries in the current directory and determines their type. For regular files, it applies filtering rules, such as excluding hidden files, and then calls the readFile function. For directories, the function opens the subdirectory and calls itself recursively, enabling the program to search through nested directories to any depth.\par

\noindent The readFile function reads the entire content of a file into memory managed by the allocator. It then processes the file line by line, checking each line against the compiled regular expression pattern. If a line matches, it is printed according to the user-specified options, such as color highlighting, context lines, and whether to show the file name. One last important step is a final check. This final check ensures that even the last line of a file, which may not end with a newline character, is included in the search and processed according to the user-specified options.
To run the program, an executable file is required. For this reason, there is an additional file called build.zig. This file enables the creation of the executable called searcher. To achieve this, the user needs to build the program using the following command in the command line: zig build. After the building is completed, the user can use the expression [path of the executable pattern file options].


\noindent While developing the search program, several positive aspects of the Zig programming language became visible. First, the standard library provides a wide range of useful functionality, such as file system access, string manipulation, and ASCII conversion. This allowed many features to be implemented directly without relying on additional external libraries. Another advantage is the explicit memory management. Using allocators and manually freeing memory with defer and free gives the developer full control over resource usage, which helps avoid memory leaks and makes program behavior more predictable. It also gives users (like myself), who do not have a lot of experience with manual control over resources, a new perspective on the administration of resources. Additionally, Zig’s error handling with the try keyword enforces early handling of potential failures, leading to more robust code. Overall, these characteristic features made certain areas of programming a lot clearer, because the user needs to understand the control over data a little bit more.

\noindent Now I want to discuss some aspects that made certain features more challenging to implement. One example is the reading of files, which is currently not as fast and efficient as it could be. Currently, the program uses a hard-coded value for the allocation of the memory size. This approach has the problem that larger files will not be processed correctly or may fail completely, because the file size is larger than the allocated space. This issue shows one of the challenges of working with Zig during the ongoing development. The language is still frequently changing, and several core functions related to input/output and memory management have been completely reworked over recent versions. As a result, a big part of the available documentation, tutorials, and community posts were outdated, and newer information was rarely available. This made finding solutions more difficult, as attempts to follow existing guidance frequently led to trying outdated implementations of the standard library. Another frustrating aspect of programming in Zig was the limited explanation of certain standard library functions, which made understanding their behavior and usage significantly more challenging.
\newpage
\section{Conclusion}
The work shows that Zig has potential to fulfill the demands of the modern Software development, through combining old strengths, while developing new approaches to enable improved memory management without losing performance. This successful strategy is reflected in the use of Zig in some large-scale projects, despite its pre 1.0 state. A noteworthy highlight is the foundation and people who stand behind Zig. Due to the approach of a non-profit foundation, Zig shows the goal of developing a technically innovative language, rather than prioritizing the profit motives of a large technology company. The model strengthens the trust of both donors and the community by showing them how the money gets spent and also ensuring that they contribute to technical progress.
The findings of this work were also demonstrated in the implementation of the grep-like program. New developers to the language can experience the unique characteristics of Zig while being supported by its infrastructure. Especially error handling and memory allocation are features that play a significant role when programming in Zig. Although some challenges remained while building the code, a big part of these problems was due to the ongoing development, which led to larger changes in the latest versions of the language. Such changes cause helpful materials to become outdated and greatly complicate implementation.
All in all, Zig is a promising programming language with the potential to become a big name in the market for systems programming languages. Despite its short lifespan, it is already featured in many  projects, and with further development, its use cases are expected to grow.
\newpage

\printbibliography
\end{document}
